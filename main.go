package main

import (
	"net/http"
	"log"
	"encoding/json"
)

type DBResp struct {

}

func (resp *DBResp) RowsAffected() (interface{}, error) {
	return nil, nil
}

type DB struct {

}

func (db *DB) Exec(query string) (*DBResp, error) {
	return nil, nil
}

var db = new(DB)

// 1. Найти и исправить принципиальные ошибки в коде, считаем все используемы объекты загружены:

// 1.1. Разбор
// Здесь я опишу комментарии, что я считаю не так с кодом

// Ошибка: во-первых, нет указания значения возврата функции. Какой именно должен быть возврат укажу около return
func object_input_insert(r *http.Request) (error, string) {
	// Ошибка: указывается переменная, которой присваивается значение,
	// но оно нигде не использутеся. Требуется убрать.
	var flag string
	// Ошибка: ранее переменная не была определена, поэтому требуется использовать символ `:=`
	// Ошибка: сюда не передается ничего из запроса, это не совсем корректно
	// Вопрос: а почему вообще вставляется `id` в базу данных? Можно делать кастомные id,
	// чтобы исключить возможность иттерации по базе из вне или скрыть количество записей.
	// Может быть это пользовательский `id`?
	// Я бы убрал это.
	query = "insert into test (id, text) values (1, 'text')"
	res, err := db.Exec(query)
	if err != nil {
		// Дополнение: по-хорошему стоит использовать готовые библиотеки для вывода логов, например, ...
		// Ошибка: данных об ошибке будет слишком мало, будет выведен только текст ошибки, но не будет стэка
		log.Print("Ошибка взаимодействия с БД (", err, ")!")
	} else {
		// Ошибка: переменной response не существует. Требуется убрать ее.
		// Ошибка: переменная ra никак не используется. Требуется заменить ее на `_`
		// Ошибка: не стоит перезаписывать вышенаходящуюся переменную ошибки err, иначе будет сложно отследить
		// в каком месте она перестала быть nil
		// Комментарий: я не знаю какая именно ДБ используется или какая библиотека, поскольку разные библиотеки могут отдавать разные данные
		ra, err := response.RowsAffected()
		// Ошибка: указывается не тот тип переменной + данная переменная вообще не используется, поэтому стоит ее убрать.
		flag = 3
		// Комментарий: странно, что результат выводится в ошибке, лучше помнять эти строки.
		log.Print("Результат: ", " (", err, ")")
	}

	// Ошибка: не стоит возвращать просто текст ошибки, поскольку возврат string из функции не говорит точно, что произошло.
	// Требуется возвращать именно ошибку, а вот во что ее преобразовывать должна решать функция, на которую
	// возложена данная ответственность (например, функция записи ответа в http.Response)
	// Комментарий: не помню, чтобы у струтукры Error было свойство `String`
	return err.String
}

// 1.1. Коррекция

type TestJSON struct {
	Text string
}

func object_input_insert_correct(r *http.Request) error {

	// Комментарий: поскольку здесь производится `insert`, я предполагаю, что это POST запрос, у которого есть тело.
	// Если это не POST, то роутер не пропустит запрос до данного уровня, поэтому здесь не требуется валидация.
	// Комментарий: также, я предположу, что используется JSON
	dc := json.NewDecoder(r.Body)
	var reqB TestJSON
	if err := dc.Decode(&reqB); err != nil {
		log.Print("Ошибка парсинга запроса (", err, ")!")
		return err
	}
	defer r.Body.Close()


	// Комментарий: здесь нужно сделать escape
	query := "insert into test (text) values ('text')"

	resp, err := db.Exec(query)

	if err != nil {
		log.Print("Ошибка взаимодействия с БД (", err, ")!")
		// Комментарий: Я предпочитаю явно возвращать ошибку, в месте, где она должна оставновить код
		return err
	} else {
		_, errRows := resp.RowsAffected()
		if errRows != nil {
			log.Print("Ошибка получения строк: ", " (", err, ")")
			return errRows
		}
	}

	// Комментарий: Я предпочитаю явно указывать на отсутствие ошибки, в случае правильного прохождения кода
	return nil
}

// P.S. Есть классная статья, в которой описано почему не стоит использовать стандартный http пакет
// https://medium.com/@nate510/don-t-use-go-s-default-http-client-4804cb19f779


func main() {

}
